## 第1章 概览 ##

### 1. 使用C语言的7个步骤 ###

 1. 定义程序目标
 2. 设计程序
 3. 编写代码
 4. 编译
 5. 运行程序
 6. 测试和调试程序
 7. 维护和修改程序
 

### 2. 编译器和链接器的作用 ###

 1. 编译器：把源代码转换成机器语言代码，即目标代码
 
 2. 链接器：把多个来源（例如，已编译的源代码、库代码和启动代码）的目标代码连接成一个单独的可执行程序
 

## 第2章 C语言概述 ##

 1. C99标准允许一个标识符最多可以有**63**个字符
 
 2. 操作系统和C库通常使用以一个或两个下划线开始的名字
 
 3. 转义字符：通常用于代表难于表达的或是无法键入的字符
 
 4. 程序状态(program state)：指在程序执行过程中给定点上所有变量值的集合


## 第3章 数据和C ##

### 1. 数据类型关键字
 1. 数据类型按其在计算机中的存储方式被划分为两个系列：整数类型和浮点类型
 
 2. 最小的存储单位称为**位**，位是计算机存储的基本单位，字是自然的存储单位

 3. 浮点数往往只是实际值的近似
 

### 2. C数据类型
 4. C的各种整数类型的区别在于所提供数值的范围，以及数值是否可以取负值
 
 5. 系统通过使用一个指示正负符号的特定位来表示有符号整数
 

 6. 最好避免在一个声明语句中同时出现初始化和未初始化的变量，如`int dogs, cats = 94;`

 7. %d被称为格式说明符，必须确保格式说明符的数目同待打印值的数目相同，编译器不会发现这类错误；C通过一种函数原型机制检查函数调用是否使用了正确数目及类型的参数，但这对参数数目可变的printf()和scanf()不起作用

 8. 前缀0x或者0X表示使用十六进制，前缀0表示使用八进制；**%o**用于显示八进制整数,**%x**用于显示十六进制；可以使用说明符**%#o**、**%#x**和**%#X**分别生成前缀0、0x和0X
 9. C99增加了**unsigned long long int**（简写为unsigned long long）类型

 10. 为了适应不同机器，C仅保证short类型不会比int类型长，并且long类型不会比int类型短

 11. 在long类型大于int类型的系统中，使用long类型会减慢计算

 12. 建议使用L后缀显式标识long类型值，使用LL后缀显式标识long long类型值

 13. **%ho**表示以八进制显式short整数

 14. C将字符常量视为int类型而非char类型，如`char grade = 'B'`，这里'B'作为数值存储在一个32位单元中，而赋值后的grade则把66存储在一个8位单元中，利用这种特性，可以定义一个字符常量'FATE'，这将把4个独立的8位ASCII码存储在一个32位单元中，若把该字符常量赋值给一个char变量，那么变量值位'E'

 15. 在ASCII码和转义序列之间优先选择使用转义序列；当需要使用数值编码时，应使用'\032'而非032，因为'\032'这样的转义序列可以嵌入到C字符串中

 16. 浮点常量最基本的形式：包含一个小数点的一个带符号的数字序列，接着是字母e或E，然后是代表10的指数的一个有符号值

 17. 在浮点常量中不要使用空格，如`1.56 E+12`；可以通过f或F后缀使编译器把浮点常量当作float类型，没有后缀的浮点常量默认为double类型

 18. printf()函数使用**%f**格式说明符打印十进制计数法的float和double数字，用**%e**打印指数计数法的数字；打印long double类型需要用**%Lf**、**%Le**和**%La**说明符

 19. 未在原型中显式说明参数类型的函数（如printf()）传递参数时，C自动将float类型的参数转换为double类型


### 3. 参数和易犯的错误

 1. 使用**%d**显示float值不会把该float值转换为近似的int值，而是显示垃圾值；使用**%f**显示int值也不会把该int值转换为浮点值，同样显示垃圾值
 

### 4. 刷新输出

 1. 标准C规定以下几种情况会将缓冲区内容传给屏幕：缓冲区满、遇到换行符、需要输入的时候；除此之外，使用fflush()函数也可以刷新输出缓冲区


## 第4章 字符串和格式化输入/输出

### 1. 字符串简介

 1. **\0**表示空字符，C用它来标记字符串的结束；空字符不是数字0，是非打印字符，其ASCII码值为0
 
 2. scanf()读取输入时在遇到第一个空白字符空格、制表符或者换行符时停止读取
 
 3. strlen()函数以字符为单位计算字符串的长度，字符串结束符'\0'不计算在内
 
 4. 一些ANSI之前的UNIX系统使用头文件strings.h而非string.h
 
 5. sizeof运算符把标识字符串结束的不可见的空字符'\0'也计算在内；sizeof是否使用圆括号取决于是想获取一个类型的大小还是想获取某个具体量的大小；圆括号对于类型是必需的，而对于具体量则是可选的，但建议都使用圆括号，如：`sizeof(char)`、`sizeof(6.28)`
 

### 2. printf()和scanf()

 1. printf()函数的转换说明符及作为结果的打印输出
 > **%a** / **%A**：浮点数、十六进制数字和p-计数法(C99)

 > **%g** / **%G**：根据数值不同自动选择**%f**或**%e**
 
 > **%p**：指针
 
 > **%%**：打印一个百分号
 
 2. printf()和其他任何不使用显式原型的C函数的所有float参数会自动被转换成double
 
 3. 不匹配的浮点数转换，如下所示:
 ```
    #include <stdio.h>
    int main(void)
    {
        float n1 = 3.0;
        double n2 = 3.0;
        long n3 = 2000000000;
        long n4 = 1234567890;
    
        printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
        printf("%ld %ld\n", n3, n4);
        printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
    
        return 0;
    }
    结果如下：
    3.0e+00 3.0e+00 3.1e+46 2.2e-314
    2000000000 1234567890
    0 1074266112 0 1074266112
 ```
 由上可见，程序试图使用**%ld**打印一个long类型居然也失败了,因为printf()一次按格式说明符从栈顶取出相应大小的数据，详情请查看P75-76
 
 4. printf()函数的返回值表示打印字符的数目(统计字符数目时，针对所有的打印字符，包括空格和不可见的换行字符)，如果输出有错误，那么printf()返回一个负数
 
 5.  当一行代码太长需要换行时，如果使用'\'，则下一行必须从行的最左边开始
 
 6. 参数：printf()使用变量名、常量和表达式；scanf()使用指向变量的指针
 
 7. printf()把**%f**、**%e**、**%E**、**%g**和**%G**同时用于float类型和double类型，而scanf()只把它们用于float类型，而用于double类型时要求使用**l**修饰
 
 8. scanf()读取时持续读取和保存字符直到它遇到第一个非数字的字符，scanf()把这个非数字字符放回输入缓冲
 
 9. 当scanf()把字符串存放在一个指定的数组中时，会添加终止符**'\0'**
 
 10. scanf()格式字符串中的常规字符，如：`scanf("%d, %d", &n, &m);`则在输入时第一个数字后必须紧跟着输入一个逗号
 
 11. scanf()格式字符串中的空格意味着跳过下一个输入项之前的任何空格(包括没有空格);如果在格式字符串中**%c**之前有一个空格，那么scanf()会跳到第一个非空白字符处
 
 12. scanf()返回成功读入的项目的个数；若没有任何读入，返回0；若检测到文件结尾，返回**EOF**
 
 13. printf()和scanf()的**\***修饰符：对于printf()必须使用一个参数来告诉函数该**\***是什么；对于scanf()，当**\***放在**%**和说明符字母之间时，是函数跳过相应的输入项目,比如可用于读取一个文件中某个特定的列
 

## 第5章 运算符、表达式和语句
 
### 1. 基本运算符

 1. 数据对象、左值、右值和操作数
 
 > 数据对象：泛指数据存储区

 > 左值：用于标识一个特定的数据对象的名字或表达式
 
 > 右值：能赋值给可修改的左值的量
 
 > 操作数：运算符操作的对象
    
 2. C90标准将一元 **+** 运算符加进了C中，该运算符**不改变它的操作数的值或符号**

 3. 在C中，整数除法结果的小数部分被丢弃，称为**截尾**

 4. 运算符的结合性只适用于共享同一操作数的运算符

### 2. 其他运算符

 1. **sizeof**运算符以字节为单位返回其操作数的大小；该操作数可以是一个具体的数据对象，或者一个类型；如果它是一个类型，操作数必须被括在圆括号内；通常应使用圆括号将操作数括起来
 
 2. 取模运算只针对整数而言，负数取模，结果的符号由第一个操作数的符号决定
 
 3. 在同一个位置执行循环的判断和循环的改变可以防止忘记更新循环而导致死循环，如**`while (count++ < 10)`**
 
 4. 增量运算符 **++** 通常能产生更高效的机器语言代码
 
 5. 避免使用前缀形式和后缀形式将导致不同效果的代码，如不要使用 **`b = ++i;`** 而应使用 **`++i; b =i;`** 来代替
 
 6. 增量运算符和减量运算符只能影响一个变量，如 **`(x * y)++`** 是无效的
 
 7. 在C中编译器可以选择优先计算函数里的哪个参数的值
 
 8. 使用自增自减运算符时应当注意：
 
 > 如果一个变量出现在同一个函数的多个参数中时，不要将增量或者减量运算符用于该变量

 > 当一个变量多次出现在一个表达式里时，不要将增量或者减量运算符运用于该变量
 
 
### 3. 表达式和语句

 1. **程序**：一系列带有某种必需的标点的语句的集合

 2. 一个语句是一条完整的指令，但不是所有完整的指令都是语句，如 **`x = 6 + (y = 5);`** **y = 5**是一个完整的指令，但不是一个语句
 
 3. **副作用**：对数据对象或文件的修改
 
 4. **顺序点**：程序中执行的一点，所有的副作用都在进入下一步之前被计算
 
 5. **复合语句**：使用花括号组织起来的两个或更多的语句


### 4. 类型转换

 1. 类型转换的基本规则：
 > **a.** 当出现在表达式里，有符号和无符号的char和short类型都将自动被转换为int，在需要的时候，将自动转换为unsigned int(如果short与int有相同的大小，那么unsigned short比int大，这时将把unsigned short转换为unsigned int)
 
 > **b.** 在包含两种数据类型的任何运算里，两个值都将被转换为两种类型里较高的级别

 > **c.** 类型级别从高到低的顺序：long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int; (注：当long和int具有相同大小时，unsigned int 比 long 的级别更高)

 > **d.** 在赋值语句里，计算的最后结果被转换成将被赋予值的那个变量的类型
 
 > **e.** 当作为函数的参数被传递时，char和short会被转换为int，float会被转换成double
 
 2. 指派运算符：**(type)**，如 **`float f = 1.2f; int a = (int)f;`**


### 5. 带有参数的函数

 1. C99规定：对实际参数或者实际参量使用术语 ***参数*** ； 对形式参数或者形式参量使用术语 ***参量***
 
 2. 函数原型：是一个函数声明，描述了函数的返回值和参数
 
 3. 每个运算符的特性包括：所需操作数的数量、优先级和结合性



 
## 第6章 C控制语句：循环

### 1. while语句

 1. 每次循环都被称为一次迭代
 
 2. 若while语句块为空语句，应该将分号放在下面的一行而不是放在同一行中，如下：

    ```
    while (scanf("%d", &num) == 1)
        ;
    ```
  
    
### 2. 比较大小：使用关系运算符和表达式

 1. 在浮点数比较中只能使用**>**和**<**
 
 2. 如果进行比较的双方中有一个是常量，则可以把它放在比较表达式的左边
 
 3. 一个**_Bool**变量只可以具有值1(真)或0(假)，如果把一个非零的值赋给**_Bool**变量，则**_Bool**变量被设置为1
 
 4. C99还提供了一个stdbool.h头文件，可以使用bool来代替_Bool，并把true和false定义为值1和0的符号常量，通过这种方式可以和C++兼容

### 3. 退出条件循环：do while

 1. while循环和for循环是入口条件循环，do while循环是退出条件循环
 
 2. do while循环本身就是一个语句，因此需要一个结束的分号
 
 3. C99允许使用常量值制定数组大小，而C90不允许，但#define在两种情况下都可以使用
 
 4. 现代编程习惯把程序的元素分为接口和实现两部分

## 第7章 C控制语句：分支和跳转

### 1. if语句

 1. 在需要类型转换的地方，建议使用显式类型转换
 
 2. C99标准要求编译器至少支持127层嵌套

### 2. 求值的顺序

 1. 除了两个运算符共享一个操作数的情况以外，C通常不保证复杂表达式的哪个部分首先被求值
 
 2. 判断一个字符是否是字符时，建议使用移植性更好的方法：使用ctype.h中声明的函数

### 3. 多重选择：switch和break

 1. **switch**判断表达式应该具有整数值(包括char类型)；case标签必须是整型(包括char)常量或者整数常量表达式(仅包含整数常量的表达式)

## 第8章 字符输入/输出和输入确认
### 1. 单字符I/O：getchar()和putchar()

 1. 输入回显：获取从键盘输入的字符并将其发送至屏幕

### 2. 缓冲区

 1. 缓冲分为两类：完全缓冲I/O和行缓冲I/O；对于完全缓冲输入来说，缓冲区满时被清空，通常出现在文件输入中，缓冲区的大小取决于系统；对行缓冲I/O来说，遇到一个换行符时将被清空缓冲区，键盘输入是标准的行缓冲
 
 2. 文件结束符：Ctrl+D

### 3. 重定向和文件

 1. 使用重定向运算符(>、>>、<等)时，输入不能来自一个以上的文件，输出也不能定向至一个以上的文件

## 第9章 函数

### 1. 函数概述

 1. 函数：用于完成特定任务的程序代码的自包含单元
 
 2. **return;** 只能用于void类型的函数中

### 2. ANSI C的函数原型

 1. 函数原型用来声明函数的返回值类型，参数个数以及各参数的类型；函数原型中可以省略参数变量名，函数原型中的参数变量名只是虚设的名字，不必和函数定义中使用的参数变量名想匹配；
 
 2. 若使用函数原型 **void print_name();** ，ANSI C编译器不会进行参数检查；为了表示一个函数确实不适用参数，应当在圆括号内使用**void**关键字，如：**void print_name(void);**，这时当对该函数进行调用时，ANSI C编译器会检查函数参数以保证确实没有使用参数

### 3. 多源代码文件程序的编译

 1. 编译第一个文件并将其链接到第二个文件的目标代码中：**gcc file1.c file2.o**
 
 2. 在UNIX和DOS环境下，**#include "hotel.h"** 中的双引号表示被包含的文件位于当前工作目录下

### 4. 指针简介

 1. 指针变量**ptr**和**&pooh**的区别：**ptr**为变量，而**&pooh**为常量
 
 2. ***** 和指针名之间的空格是可选的，通常在声明中使用空格，而在指向变量时省略空格
 
 3. 函数的参数用于函数间通信，输入参数可以把调用函数中的数值传递给被调用函数，输出参数可以把被调用函数中的数值传递给调用函数

  
 
 
 
  
 

 

 
 
 

 
 
 
 
 