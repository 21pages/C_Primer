## 第1章 概览 ##

### 1. 使用C语言的7个步骤 ###

 1. 定义程序目标
 2. 设计程序
 3. 编写代码
 4. 编译
 5. 运行程序
 6. 测试和调试程序
 7. 维护和修改程序
 

### 2. 编译器和链接器的作用 ###

 1. 编译器：把源代码转换成机器语言代码，即目标代码
 
 2. 链接器：把多个来源（例如，已编译的源代码、库代码和启动代码）的目标代码连接成一个单独的可执行程序
 

## 第2章 C语言概述 ##

 1. C99标准允许一个标识符最多可以有**63**个字符
 
 2. 操作系统和C库通常使用以一个或两个下划线开始的名字
 
 3. 转义字符：通常用于代表难于表达的或是无法键入的字符
 
 4. 程序状态(program state)：指在程序执行过程中给定点上所有变量值的集合


## 第3章 数据和C ##

### 1. 数据类型关键字
 1. 数据类型按其在计算机中的存储方式被划分为两个系列：整数类型和浮点类型
 
 2. 最小的存储单位称为**位**，位是计算机存储的基本单位，字是自然的存储单位

 3. 浮点数往往只是实际值的近似
 

### 2. C数据类型
 4. C的各种整数类型的区别在于所提供数值的范围，以及数值是否可以取负值
 
 5. 系统通过使用一个指示正负符号的特定位来表示有符号整数
 

 6. 最好避免在一个声明语句中同时出现初始化和未初始化的变量，如`int dogs, cats = 94;`

 7. %d被称为格式说明符，必须确保格式说明符的数目同待打印值的数目相同，编译器不会发现这类错误；C通过一种函数原型机制检查函数调用是否使用了正确数目及类型的参数，但这对参数数目可变的printf()和scanf()不起作用

 8. 前缀0x或者0X表示使用十六进制，前缀0表示使用八进制；**%o**用于显示八进制整数,**%x**用于显示十六进制；可以使用说明符**%#o**、**%#x**和**%#X**分别生成前缀0、0x和0X
 9. C99增加了**unsigned long long int**（简写为unsigned long long）类型

 10. 为了适应不同机器，C仅保证short类型不会比int类型长，并且long类型不会比int类型短

 11. 在long类型大于int类型的系统中，使用long类型会减慢计算

 12. 建议使用L后缀显式标识long类型值，使用LL后缀显式标识long long类型值

 13. **%ho**表示以八进制显式short整数

 14. C将字符常量视为int类型而非char类型，如`char grade = 'B'`，这里'B'作为数值存储在一个32位单元中，而赋值后的grade则把66存储在一个8位单元中，利用这种特性，可以定义一个字符常量'FATE'，这将把4个独立的8位ASCII码存储在一个32位单元中，若把该字符常量赋值给一个char变量，那么变量值位'E'

 15. 在ASCII码和转义序列之间优先选择使用转义序列；当需要使用数值编码时，应使用'\032'而非032，因为'\032'这样的转义序列可以嵌入到C字符串中

 16. 浮点常量最基本的形式：包含一个小数点的一个带符号的数字序列，接着是字母e或E，然后是代表10的指数的一个有符号值

 17. 在浮点常量中不要使用空格，如`1.56 E+12`；可以通过f或F后缀使编译器把浮点常量当作float类型，没有后缀的浮点常量默认为double类型

 18. printf()函数使用**%f**格式说明符打印十进制计数法的float和double数字，用**%e**打印指数计数法的数字；打印long double类型需要用**%Lf**、**%Le**和**%La**说明符

 19. 未在原型中显式说明参数类型的函数（如printf()）传递参数时，C自动将float类型的参数转换为double类型


### 3. 参数和易犯的错误

 1. 使用**%d**显示float值不会把该float值转换为近似的int值，而是显示垃圾值；使用**%f**显示int值也不会把该int值转换为浮点值，同样显示垃圾值
 

### 4. 刷新输出

 1. 标准C规定以下几种情况会将缓冲区内容传给屏幕：缓冲区满、遇到换行符、需要输入的时候；除此之外，使用fflush()函数也可以刷新输出缓冲区


## 第4章 字符串和格式化输入/输出

### 1. 字符串简介

 1. **\0**表示空字符，C用它来标记字符串的结束；空字符不是数字0，是非打印字符，其ASCII码值为0
 
 2. scanf()读取输入时在遇到第一个空白字符空格、制表符或者换行符时停止读取
 
 3. strlen()函数以字符为单位计算字符串的长度，字符串结束符'\0'不计算在内
 
 4. 一些ANSI之前的UNIX系统使用头文件strings.h而非string.h
 
 5. sizeof运算符把标识字符串结束的不可见的空字符'\0'也计算在内；sizeof是否使用圆括号取决于是想获取一个类型的大小还是想获取某个具体量的大小；圆括号对于类型是必需的，而对于具体量则是可选的，但建议都使用圆括号，如：`sizeof(char)`、`sizeof(6.28)`
 

### 2. printf()和scanf()

 1. printf()函数的转换说明符及作为结果的打印输出
>**%a** / **%A**：浮点数、十六进制数字和p-计数法(C99)
 **%g** / **%G**：根据数值不同自动选择**%f**或**%e**
 **%p**：指针
 **%%**：打印一个百分号
 
 2. printf()和其他任何不使用显式原型的C函数的所有float参数会自动被转换成double
 
 3. 不匹配的浮点数转换，如下所示:
 ```
    #include <stdio.h>
    int main(void)
    {
        float n1 = 3.0;
        double n2 = 3.0;
        long n3 = 2000000000;
        long n4 = 1234567890;
    
        printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
        printf("%ld %ld\n", n3, n4);
        printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
    
        return 0;
    }
    结果如下：
    3.0e+00 3.0e+00 3.1e+46 2.2e-314
    2000000000 1234567890
    0 1074266112 0 1074266112
 ```
 由上可见，程序试图使用**%ld**打印一个long类型居然也失败了,因为printf()一次按格式说明符从栈顶取出相应大小的数据，详情请查看P75-76
 
 4. printf()函数的返回值表示打印字符的数目(统计字符数目时，针对所有的打印字符，包括空格和不可见的换行字符)，如果输出有错误，那么printf()返回一个负数
 
 5.  当一行代码太长需要换行时，如果使用'\'，则下一行必须从行的最左边开始
 
 6. 参数：printf()使用变量名、常量和表达式；scanf()使用指向变量的指针
 
 7. printf()把**%f**、**%e**、**%E**、**%g**和**%G**同时用于float类型和double类型，而scanf()只把它们用于float类型，而用于double类型时要求使用**l**修饰
 
 8. scanf()读取时持续读取和保存字符直到它遇到第一个非数字的字符，scanf()把这个非数字字符放回输入缓冲
 
 9. 当scanf()把字符串存放在一个指定的数组中时，会添加终止符**'\0'**
 
 10. scanf()格式字符串中的常规字符，如：`scanf("%d, %d", &n, &m);`则在输入时第一个数字后必须紧跟着输入一个逗号
 
 11. scanf()格式字符串中的空格意味着跳过下一个输入项之前的任何空格(包括没有空格);如果在格式字符串中**%c**之前有一个空格，那么scanf()会跳到第一个非空白字符处
 
 12. scanf()返回成功读入的项目的个数；若没有任何读入，返回0；若检测到文件结尾，返回**EOF**
 
 13. printf()和scanf()的**\***修饰符：对于printf()必须使用一个参数来告诉函数该**\***是什么；对于scanf()，当**\***放在**%**和说明符字母之间时，是函数跳过相应的输入项目,比如可用于读取一个文件中某个特定的列
 

## 第5章 运算符、表达式和语句
 
 

 

 
 
 

 
 
 
 
 